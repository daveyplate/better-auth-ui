{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-conditional-query",
  "type": "registry:lib",
  "title": "Use Conditional Query",
  "description": "",
  "dependencies": [
    "@triplit/client",
    "@triplit/react"
  ],
  "registryDependencies": [],
  "files": [
    {
      "path": "src/lib/triplit/use-conditional-query.ts",
      "content": "import type {\n    FetchResult,\n    Models,\n    SchemaQuery,\n    SubscriptionOptions,\n    SubscriptionSignalPayload,\n    TriplitClient\n} from \"@triplit/client\"\nimport type { WorkerClient } from \"@triplit/client/worker-client\"\nimport { createStateSubscription } from \"@triplit/react\"\nimport { useCallback, useMemo, useState, useSyncExternalStore } from \"react\"\n\nexport function useConditionalQuery<\n    M extends Models<M>,\n    Q extends SchemaQuery<M>\n>(\n    client: TriplitClient<M> | WorkerClient<M>,\n    query?: Q | false | null | \"\" | 0,\n    options?: Partial<SubscriptionOptions> & { disabled?: boolean }\n) {\n    const stringifiedQuery =\n        !options?.disabled && query && JSON.stringify(query)\n    const localOnly = !!options?.localOnly\n    const [remoteFulfilled, setRemoteFulfilled] = useState(false)\n\n    const defaultValue: SubscriptionSignalPayload<M, Q> = {\n        results: undefined,\n        fetching: true,\n        fetchingLocal: false,\n        fetchingRemote: false,\n        error: undefined\n    }\n\n    // biome-ignore lint/correctness/useExhaustiveDependencies: prevent infinite re-renders\n    const [subscribe, snapshot] = useMemo(\n        () =>\n            stringifiedQuery\n                ? createStateSubscription(client, query, {\n                      ...options,\n                      onRemoteFulfilled: () => setRemoteFulfilled(true)\n                  })\n                : [() => () => {}, () => defaultValue],\n        [stringifiedQuery, localOnly]\n    )\n\n    const getServerSnapshot = useCallback(() => snapshot(), [snapshot])\n    const { fetching, ...rest } = useSyncExternalStore(\n        subscribe,\n        snapshot,\n        getServerSnapshot\n    )\n    return { fetching: fetching && !remoteFulfilled, ...rest }\n}\n\ntype useConditionalQueryOnePayload<\n    M extends Models<M>,\n    Q extends SchemaQuery<M>\n> = Omit<SubscriptionSignalPayload<M, Q>, \"results\"> & {\n    result: FetchResult<M, Q, \"one\">\n}\n\nexport function useConditionalQueryOne<\n    M extends Models<M>,\n    Q extends SchemaQuery<M>\n>(\n    client: TriplitClient<M> | WorkerClient<M>,\n    query?: Q | false | null | \"\" | 0,\n    options?: Partial<SubscriptionOptions> & { disabled?: boolean }\n): useConditionalQueryOnePayload<M, Q> {\n    const { fetching, fetchingLocal, fetchingRemote, results, error } =\n        useConditionalQuery(\n            client,\n            query ? ({ ...query, limit: 1 } as Q) : query,\n            options\n        )\n\n    const result = useMemo(() => {\n        return results?.[0] ?? null\n    }, [results])\n\n    return { fetching, fetchingLocal, fetchingRemote, result, error }\n}\n",
      "type": "registry:lib"
    }
  ]
}