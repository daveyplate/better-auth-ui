{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-auth-data",
  "type": "registry:hook",
  "title": "Use Auth Data",
  "description": "",
  "dependencies": [],
  "registryDependencies": [
    "https://better-auth-ui.com/r/auth-data-cache.json",
    "https://better-auth-ui.com/r/auth-ui-provider.json",
    "https://better-auth-ui.com/r/fetch-error.json",
    "https://better-auth-ui.com/r/utils.json"
  ],
  "files": [
    {
      "path": "src/hooks/use-auth-data.ts",
      "content": "import {\n    useCallback,\n    useContext,\n    useEffect,\n    useRef,\n    useState,\n    useSyncExternalStore\n} from \"react\"\n\nimport { authDataCache } from \"../lib/auth-data-cache\"\nimport { AuthUIContext } from \"../lib/auth-ui-provider\"\nimport { getLocalizedError } from \"../lib/utils\"\nimport type { FetchError } from \"../types/fetch-error\"\n\nexport function useAuthData<T>({\n    queryFn,\n    cacheKey,\n    staleTime = 10000 // Default 10 seconds\n}: {\n    queryFn: () => Promise<{ data: T | null; error?: FetchError | null }>\n    cacheKey?: string\n    staleTime?: number\n}) {\n    const {\n        hooks: { useSession },\n        toast,\n        localization\n    } = useContext(AuthUIContext)\n    const { data: sessionData, isPending: sessionPending } = useSession()\n\n    // Generate a stable cache key based on the queryFn if not provided\n    const queryFnRef = useRef(queryFn)\n    queryFnRef.current = queryFn\n\n    const stableCacheKey = cacheKey || queryFn.toString()\n\n    // Subscribe to cache updates for this key\n    const cacheEntry = useSyncExternalStore(\n        useCallback(\n            (callback) => authDataCache.subscribe(stableCacheKey, callback),\n            [stableCacheKey]\n        ),\n        useCallback(\n            () => authDataCache.get<T>(stableCacheKey),\n            [stableCacheKey]\n        ),\n        useCallback(\n            () => authDataCache.get<T>(stableCacheKey),\n            [stableCacheKey]\n        )\n    )\n\n    const initialized = useRef(false)\n    const previousUserId = useRef<string | undefined>(undefined)\n    const [error, setError] = useState<FetchError | null>(null)\n\n    const refetch = useCallback(async () => {\n        // Check if there's already an in-flight request for this key\n        const existingRequest = authDataCache.getInFlightRequest<{\n            data: T | null\n            error?: FetchError | null\n        }>(stableCacheKey)\n        if (existingRequest) {\n            // Wait for the existing request to complete\n            try {\n                const result = await existingRequest\n                if (result.error) {\n                    setError(result.error)\n                } else {\n                    setError(null)\n                }\n            } catch (err) {\n                setError(err as FetchError)\n            }\n            return\n        }\n\n        // Mark as refetching if we have cached data\n        if (cacheEntry?.data !== undefined) {\n            authDataCache.setRefetching(stableCacheKey, true)\n        }\n\n        // Create the fetch promise\n        const fetchPromise = queryFnRef.current()\n\n        // Store the promise as in-flight\n        authDataCache.setInFlightRequest(stableCacheKey, fetchPromise)\n\n        try {\n            const { data, error } = await fetchPromise\n\n            if (error) {\n                setError(error)\n                toast({\n                    variant: \"error\",\n                    message: getLocalizedError({ error, localization })\n                })\n            } else {\n                setError(null)\n            }\n\n            // Update cache with new data\n            authDataCache.set(stableCacheKey, data)\n        } catch (err) {\n            const error = err as FetchError\n            setError(error)\n            toast({\n                variant: \"error\",\n                message: getLocalizedError({ error, localization })\n            })\n        } finally {\n            authDataCache.setRefetching(stableCacheKey, false)\n            authDataCache.removeInFlightRequest(stableCacheKey)\n        }\n    }, [stableCacheKey, toast, localization, cacheEntry])\n\n    useEffect(() => {\n        const currentUserId = sessionData?.user?.id\n\n        if (!sessionData) {\n            // Clear cache when session is lost\n            authDataCache.setRefetching(stableCacheKey, false)\n            authDataCache.clear(stableCacheKey)\n            initialized.current = false\n            previousUserId.current = undefined\n            return\n        }\n\n        // Check if user ID has changed\n        const userIdChanged =\n            previousUserId.current !== undefined &&\n            previousUserId.current !== currentUserId\n\n        // If user changed, clear cache to ensure isPending becomes true\n        if (userIdChanged) {\n            authDataCache.clear(stableCacheKey)\n        }\n\n        // If we have cached data, we're not pending anymore\n        const hasCachedData = cacheEntry?.data !== undefined\n\n        // Check if data is stale\n        const isStale =\n            !cacheEntry || Date.now() - cacheEntry.timestamp > staleTime\n\n        if (\n            !initialized.current ||\n            !hasCachedData ||\n            userIdChanged ||\n            (hasCachedData && isStale)\n        ) {\n            // Only fetch if we don't have data or if the data is stale\n            if (!hasCachedData || isStale) {\n                initialized.current = true\n                refetch()\n            }\n        }\n\n        // Update the previous user ID\n        previousUserId.current = currentUserId\n    }, [\n        sessionData,\n        sessionData?.user?.id,\n        stableCacheKey,\n        refetch,\n        cacheEntry,\n        staleTime\n    ])\n\n    // Determine if we're in a pending state\n    // We're only pending if:\n    // 1. Session is still loading, OR\n    // 2. We have no cached data and no error\n    const isPending =\n        sessionPending || (cacheEntry?.data === undefined && !error)\n\n    return {\n        data: cacheEntry?.data ?? null,\n        isPending,\n        isRefetching: cacheEntry?.isRefetching ?? false,\n        error,\n        refetch\n    }\n}\n",
      "type": "registry:hook"
    }
  ]
}